""" 
#14500 테트로미노

첫 접근 방식 -> dfs
ㅗ 모양 처리의 어려움 있었음

정사각형 4개를 이어 붙인 테트로미노 5가지를 회전을 통해 얻을 수 있는 경우의 수 = 19개
19가지를 모두 좌표로 표현
19가지 도형을 모두 좌표에 둬보면서 해당 graph 좌표의 숫자를 더해 max값 구하면됨
"""

import sys

n, m = map(int, sys.stdin.readline().split())
graph = [0]*n

for i in range(n):
    graph[i] = list(map(int, input().split()))

t_arr = [
    [[0,0], [0,1], [1,0], [1,1]], # ㅁ
    [[0,0], [0,1], [0,2], [0,3]], # ㅡ
    [[0,0], [1,0], [2,0], [3,0]], # ㅣ
    # ㄴ
    [[0,0], [1,0], [0,1], [0,2]], 
    [[0,0], [0,1], [1,1], [2,1]],
    [[1,0], [1,1], [1,2], [0,2]],
    [[0,0], [1,0], [2,0], [2,1]],
    [[0,0], [0,1], [0,2], [1,2]],
    [[2,0], [2,1], [1,1], [0,1]],
    [[0,0], [1,0], [1,1], [1,2]],
    [[2,0], [1,0], [0,0], [0,1]],
    # ㄱㄴ
    [[0,0], [0,1], [1,1], [1,2]], 
    [[0,1], [1,1], [1,0], [2,0]],
    [[1,0], [1,1], [0,1], [0,2]],
    [[0,0], [1,0], [1,1], [2,1]],
    [[0,0], [0,1], [1,1], [0,2]], # ㅗ
    [[1,0], [1,1], [0,1], [2,1]], # ㅓ
    [[1,0], [1,1], [1,2], [0,1]], # ㅜ
    [[0,0], [1,0], [2,0], [1,1]], # ㅏ
]

# 최대 합 -> 출력 값
max_total = 0

for i in range(n):
    for j in range(m):
        for k in t_arr:
            sub_total = 0
            for coordinate in k:
                # nx,ny를 t_arr의 좌표만큼 이동
                nx = i + coordinate[0]
                ny = j + coordinate[1]
                
                # 좌표가 graph 범위 밖으로 벗어나면 continue
                if (nx < 0) or (ny < 0) or (nx >=n) or (ny >= m):
                    continue
                
                # 해당 도형와 겹치는 graph의 숫자를 모두 더함
                sub_total += graph[nx][ny]
            # 더한 숫자의 값의 최댓값 
            max_total = max(max_total, sub_total)

print(max_total)