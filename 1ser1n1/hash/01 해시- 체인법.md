# 01. 해시- 체인법

## 01. 해시법

<aside>
💡 ‘데이터를 저장할 위치 = 인덱스’를 간단한 연산으로 구현하는 것
이 방법은 원소의 검색뿐 아니라 추가와 삭제도 효율적으로 수행 가능

</aside>

| 키  | 5 | 6 | 14 | 20 | 29 | 34 | 37 | 51 | 69 | 75 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 해시값(13으로 나눈 나머지) | 5 | 6 | 1 | 7 | 3 | 8 | 11 | 12 | 4 | 10 |
- 키: 원소의 값
- 해시 값: 배열의 키를 원소 개수로 나눈 나머지
- 해시 테이블: 위에서 구한 해시값을 인덱스로 하여 원소를 새로 저장한 배열
아래의 테이블에서 원소 35를 추가하고자 할 때 35를 13으로 나눈 나머지는 9이므로 인덱스9에 바로 저장이 가능하다.

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| -  | 14 | - | 29 | 69 | 5 | 6 | 20 | 34 | - | 75 | 37 | 51 |
- 해시 함수: 키를 해시값으로 변환하는 과정
- 버킷: 해시 테이블에서 만들어진 원소

### 해시 충돌

 키와 해시값은 일반적으로 다대 1(n:1)관계로 이루어져 있다. 이처럼 저장할 버킷이 중복되는 현상을 충돌이라고 한다.

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| -  | 14 | - | 29 | 69 | 5 | 6 | 20 | 34 | - | 75 | 37 | 51 |

                                                   

      ⬆️ 원소 16을 대입하고자 할때 13으로 나눈 나머지는 5 

      인덱스5는 이미 값이 들어있어 충돌 발생

**********************************충돌 대처 방법**********************************

> **체인법:** 해시값이 같은 원소를 연결 리스트로 관리
**오픈 주소법:** 빈 버킷을 찾을 때까지 해시를 반복
> 

## 02. 체인법

### 체인법이란?

 해시값이 같은 데이터를 체인 모양의 연결 리스트로 연결하는 방법

![Untitled](01%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%B5-%20%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%87%E1%85%A5%E1%86%B8%20cd3ef8a76ac04cf09b163995fcad71cf/Untitled.png)

  해시값이 같은 데이터를 연결 리스트에 의해 체인 모양으로 연결한다. 

배열의 각 버킷(해시테이블)에 저장하는 것은 인덱스를 해시값으로 하는 연결 리스트의 앞쪽 노드를 참조하는 것이다.

 예를 들어 69와 17의 해시값은 둘 다 4이며, 이들을 연결하는 연결 리스트의 앞쪽 노드를 참조하여 table[4]에 저장

---

### 해시 함수 구현

```python
#체인법으로 해시 함수 구현하기

from __future__ import annotations
from typing import Any, Type
import hashlib

class Node:
    """해시를 구성하는 노드"""

    def __init__(self, key: Any, value: Any, next: Node) -> None:
        """초기화"""
        self.key = key #키
        self.value = value #값
        self.next = next #뒤쪽 노드를 참소
```

 **************************************************Node 클래스 만들기**************************************************

Node클래스는 개별 버킷을 나타낸다. 이 클래스에는 다음과 같이 필드 3개가 존재

- **key:** 키(임의의 자료형)
- **************value:************** 값(임의의 자료형)
- ************next:************ 뒤쪽 노드를 참조(Node형)

Node클래스는 키와 값이 짝을 이루는 구조이다, 키에 해시 함수를 적용하여 해시값을 구한다.

![Untitled](01%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%B5-%20%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%87%E1%85%A5%E1%86%B8%20cd3ef8a76ac04cf09b163995fcad71cf/Untitled%201.png)

---

### ********************************************해시 클래스 구현********************************************

 Node형 인스턴스를 초기화하는 `___init___()` 함수는 3개의 인수 key, value, next를 전달받아 각각 대응하는 필드인 self.key, self.value, self.next에 대입

```python
class ChainedHash:
    """체인법으로 해시 클래스 구현"""

    def __init__(self, capacity: int) -> None:
        """초기화"""
        self.capcity = capacity #해시 테이블의 크기를 지정
        self.table = [None] * self.capcity #해시 테이블(리스트)을 선언
    
    def hash_value(self, key: Any) -> int:
        """해시값을 구함"""
        if isinstance(key, int):
            return key % self.capcity #key가 int형인 경우
        return(int(hashlib.sha256(str(key).encode()).hexdigest(),16)% self.capcity) #key가 int형이 아닌 경우
```

 ************************************************************************ChainedHash 해시 클래스 만들기************************************************************************

<aside>
💡 chainedHash 해시 클래스는 필드 2개로 구성
 - ************************************************************************capacity:************************************************************************ 해시 테이블의 크기(배열 table의 원소 수)를 나타낸다.
- ****************table :**************** 해시 테이블을 저장하는 list형 배열을 나타낸다.

</aside>

- `___init___()` **함수로 초기화 하기**

 `___init___()` 함수는 빈 해시 테이블을 생성. 매개변수 capacity에 전달받는 것은 해시 테이블의 크기이다.  

  `___init___()` 함수가 호출된 직후 배열 table의 모든 원소는 None이고 전체 버킷이 빈 상태 이다.

- `hash_value()` **해시 함수 만들기**

 `hash_value()` 함수는 인수 key에 대응하는 해시 값을 구한다.

---

### ******키로 원소를 검색하는 `search()` 함수**

![Untitled](01%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%B5-%20%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%87%E1%85%A5%E1%86%B8%20cd3ef8a76ac04cf09b163995fcad71cf/Untitled.png)

- 33 검색하기
33의 해시값은 7이므로 table[7]이 가리키는 연결 리스트를 찾아간다. 20 → 33으로 찾아가면 검색에 성공
- 26 검색하기
26의 해시값은 0이다. table[0]이 None이므로 검색에 실패한다,
- **************************************************************************************************search() 함수가 원소를 검색하는 과정**************************************************************************************************
    
    1. 해시 함수를 사용하여 키를 해시값으로 변환
    
    2. 해시값을 인덱스로 하는 버킷에 주목
    
    3. 버킷이 참조하는 연결 리스트를 맨 앞부터 차례로 스캔, 키와 같은 값이 발견되면 검색에 성공하고, 원소의 맨 끝까지 스캔해서 발견되지 않으면 검색에 실패
    

```python
def search(self, key: Any) -> Any:
        """키가 key인 원소를 검색하여 값을 반환"""
        hash = self.hash_value(key) #검색하는 key의 해시값
        p = self.table[hash] #노드를 주목

        while p is not None:
            if p.key == key:
                return p.value #검색 성공
            p = p.next #뒤쪽 노드를 주목
        
        return None #검색 실패
    
    def add(self, key: Any, value: Any) -> bool:
        """키가 key이고 값이 value인 원소를 추가"""
        hash = self.hash_value(key) #추가하는 key의 해시값
        p = self.table[hash] #노드를 주목

        while p is not None:
            if p.key == key:
                return False #추가 실패
            p = p.next #뒤쪽 노드를 주목

        temp = Node(key, value, self.table[hash]) #self.table[hash]를 함으로 현재 버킷을 참조하도록 가리킴.
        self.table[hash] = temp #맨앞으로 노드를 추가
        return True #추가 성공
```

### 원소를 추가하는 `add()` 함수

 add()함수는 키가 key이고 값이 value인 원소를 추가

- 13을 추가
    
    먼저 13의 해시값은 0이고 table[0]은 None이다. 13을 저장하는 노드를 새로 생성하고, 그 노드에 대한 참조를 table[0]에 대입한다.
    
- 46을 추가
    
    46의 해시값은 7이고 table[7] 버킷에는 20과 33을 연결한 연결 리스트에 대한 참조가 저장되어 있다. 이 리스트 안에 46은 존재하지 않으므로 연결 리스트의 맨 앞에 46을 추가한다. 
    
    구체적으로는 46을 저장하는 노드를 새로 생성하고, 그 노드에 대한 참조를 table[7]에 대입한다. 또 추가한 노드의 뒤쪽 포인터인 next가 20을 저장한 노드를 주목하도록 업데이트 한다.
    
- **********************************************************************************************add()함수가 원소를 추가하는 과정**********************************************************************************************
    1. 해시 함수를 사용하여 키를 해시값으로 변환
    2. 해시값을 인덱스로 하는 버킷에 주목
    3. 버킷이 참조하는 연결 리스트를 맨 앞부터 차례로 선형 검색을 한다. 키와 같은 값이 발견되면 키가 이미 등록된 경우이므로 추가에 실패, 원소의 맨 끝까지 발견되지 않으면 해시값인 리스트의 맨 앞에 노드를 추가

---

### 원소를 삭제하는 `remove()` 함수

- remove()함수로 원소를 삭제하는 과정
    1. 해시 함수를 사용하여 키를 해시값으로 변환
    2. 해시값을 인덱스로 하는 버킷에 주목
    3. 버킷이 참조하는 연결 리스트를 맨 앞부터 차례로 선형 검색. 키와 같은 값이 발견되면 그 노드를 리스트에서 삭제한다. 그렇지 않으면 삭제에 실패

```python
def remove(self, key: Any) -> bool:
        """키가 key인 원소를 삭제"""
        hash = self.hash_value(key) #삭제할 key의 해시값
        p = self.table[hash] #노드를 주목
        pp = None #바로앞 노드를 주목

        while p is not None:
            if p.key == key: #key를 발견하면 아래를 실행
                if pp is None:
                    self.table[hash] = p.next #해시 버킷을 뒷노드 부터 시작하도록
                else:
                    pp.next = p.next #바로 앞노드의 포인터를 뒤쪽노드로 가도록 바꿈
                return True
            pp = p #현재 노드를 바로 앞 노드로 설정
            p = p.next #뒤쪽 노드를 주목
        
        return False #삭제 실패(key가 존재하지 않음

    def dump(self) -> None:
        """해시 테이블을 덤프"""
        for i in range(self.capacity):
            p = self.table[i]
            print(i, end = '')
            while p is not None:
                print(f'  -> {p.key}({p.value})', end = '')
                p = p.next
            print()
```

### 원소를 출력하는 `dump()`함수

 dump()함수는 모든 원소를 덤프하는 것, 즉 해시 테이블의 내용을 한꺼번에 출력한다. 해시테이블의 모든 원소인 `table[0]~ table[capacity - 1]` 까지 뒤쪽 노드를 찾아가면서 각 노드의 키와 값을 출력하는 작업을 반복